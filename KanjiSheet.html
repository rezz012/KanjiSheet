<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>漢字書き取りシート自動生成 — A4横 / 9mm / 縦線</title>
<style>
  /* 인쇄: A4 가로 + 여백 10mm */
  @page { size: A4 landscape; margin: 10mm; }
  :root {
    --token-col-mm: 60;        /* 표기 칸 폭(mm) 기본값 */
    --line-thick-mm: 0.3;      /* 선 두께(mm) */
  }
  body { margin: 0; font-family: Arial, "Noto Sans JP", "Malgun Gothic", sans-serif; }
  .wrap { width: calc(297mm - 20mm); margin: 10mm auto; }
  h1 { font-size: 18px; margin: 0 0 8px; }

  /* 컨트롤 패널 (인쇄 시 숨김) */
  .panel { border: 1px solid #ccc; padding: 10px; margin-bottom: 10px; font-size: 14px; }
  .panel * { box-sizing: border-box; }
  .panel textarea { width: 100%; min-height: 120px; font-size: 14px; }
  .panel .row { display: flex; flex-wrap: wrap; gap: 10px; margin: 8px 0; align-items: center; }
  .panel label { white-space: nowrap; }
  .panel input[type="number"] { width: 90px; }
  .panel .btns { display: flex; gap: 8px; }
  .panel button { padding: 8px 12px; font-size: 14px; }
  @media print { .panel { display: none; } }

  /* 시트 표 */
  table { width: 100%; border-collapse: collapse; table-layout: fixed; }
  thead th { text-align: center; font-weight: 700; border-bottom: 1px solid #000; padding: 6px 0; }
  tr { break-inside: avoid; page-break-inside: avoid; }

  /* 왼쪽 표기 칸 */
  col.token { width: calc(var(--token-col-mm) * 1mm); }
  td.token {
    text-align: center; white-space: nowrap;
    font-size: 36px; line-height: 1.1; padding: 2px 2px;
    border-right: 1px solid #000;
    overflow: hidden; text-overflow: clip;
  }

  /* 오른쪽 따라쓰기: 윗/아랫 가로줄 + 내부 세로줄만(칸 안 비움) */
  td.lines {
    padding: 6px;
    border-top: calc(var(--line-thick-mm) * 1mm) solid #000;
    border-bottom: calc(var(--line-thick-mm) * 1mm) solid #000;
  }
  .lineband {
    display: flex;
    justify-content: space-between;   /* 세로줄을 끝↔끝까지 균등 분배 */
    align-items: center;
    height: 9mm;                      /* ← 요구: 세로 9mm 고정 */
    width: 100%;
  }
  .vline {
    display: inline-block;
    height: 100%;
    border-left: calc(var(--line-thick-mm) * 1mm) solid #000; /* 세로줄만 */
    box-sizing: border-box;
  }

  /* 1mm→px 환산용 프로브(표기칸 60mm 등 실제 px 치수 얻기) */
  #mmProbe { position: absolute; visibility: hidden; width: 60mm; height: 0; }
</style>
</head>
<body>
<div id="mmProbe"></div>
<div class="wrap">
  <h1>漢字書き取りシート自動生成</h1>

  <!-- 컨트롤 패널 -->
  <div class="panel">
    <div class="row">
      <label><input type="radio" name="mode" value="kanji" checked> 한자(문자)만 추출</label>
      <label><input type="radio" name="mode" value="words"> 간이 단어 모드(한자가 포함된 연속 문자열)</label>
      <label><input type="checkbox" id="dedupe"> 중복 제거</label>
    </div>
    <div class="row">
      <label>표기 칸 폭(mm):
        <input type="number" id="tokenMM" min="30" max="100" step="1" value="60">
      </label>
      <label>세로줄 민감도 SCALE:
        <input type="number" id="scale" step="0.1" value="1.0">
      </label>
      <label>세로줄 최소/최대:
        <input type="number" id="minLines" min="2" max="60" step="1" value="6"> /
        <input type="number" id="maxLines" min="2" max="60" step="1" value="24">
      </label>
    </div>
    <textarea id="src" placeholder="여기에 일본어 원문을 붙여넣으세요。例：要塞の中は熱気でいっぱいだった…"></textarea>
    <div class="btns">
      <button id="btnGen">Generate</button>
      <button id="btnPrint">Print</button>
      <span id="count" style="margin-left:8px;color:#555"></span>
    </div>
    <div style="font-size:12px;color:#666;margin-top:6px">
      ※ 간이 단어 모드는 공백/구두점/줄바꿈 기준으로 끊고, <b>한자가 1자 이상 포함된 덩어리</b>만 채택합니다.<br>
      ※ “중복 제거”를 끄면 원문 등장순서 그대로 모두 포함합니다(학습용 반복에 유용).
    </div>
  </div>

  <!-- 시트 -->
  <table>
    <colgroup><col class="token"><col></colgroup>
    <thead><tr><th>표기</th><th>書き取り（縦線・高さ9mm）</th></tr></thead>
    <tbody id="rows"></tbody>
  </table>
</div>

<script>
/* ==== 유틸: 정규식/분리 ==== */
const reHan    = /\p{Script=Han}/u;                           // 한자 여부
const reHanAll = /\p{Script=Han}/gu;
const reWord   = /[\p{Script=Han}\p{Script=Hiragana}\p{Script=Katakana}ー]+/gu;
function extractKanjiChars(text){ return (text.match(reHanAll) || []); }

/* ==== mm→px 측정, 폰트 측정 ==== */
const mmPer60 = document.getElementById('mmProbe').getBoundingClientRect().width; // 60mm in px
function mmToPx(mm){ return mm * (mmPer60/60); }

const canvas = document.createElement('canvas');
const ctx = canvas.getContext('2d');
const BASE_FS = 36, MIN_FS = 16;
const FONT_FAM = '"Noto Sans JP","Malgun Gothic",Arial,sans-serif';
function measurePx(text, fs){ ctx.font = fs + 'px ' + FONT_FAM; return ctx.measureText(text).width; }
function fitFontSize(text, tokenInnerPx){
  const w = measurePx(text, BASE_FS);
  if (w <= tokenInnerPx) return BASE_FS;
  const scaled = Math.floor(BASE_FS * (tokenInnerPx / Math.max(1,w)));
  return Math.max(MIN_FS, scaled);
}

/* ==== “표기 너비와 적당히 비슷”하게 세로줄 개수 산출 ==== */
function lineCountBy(tokenPxShown, writingPx, SCALE, MIN_LINES, MAX_LINES){
  // 목표 간격(segPx) = tokenPxShown * SCALE, 8~28mm 범위로 제한
  const segMinPx = mmToPx(8), segMaxPx = mmToPx(28);
  let segPx = tokenPxShown * SCALE;
  segPx = Math.max(segMinPx, Math.min(segMaxPx, segPx));

  let N = Math.round(writingPx / segPx) + 1; // N개 세로줄 → 간격 N-1개
  if (N < MIN_LINES) N = MIN_LINES;
  if (N > MAX_LINES) N = MAX_LINES;
  return N;
}

/* ==== 렌더러 ==== */
const rows = document.getElementById('rows');
function render(tokens, opts){
  // 표 비우기
  rows.innerHTML = '';
  // CSS 변수로 표기칸 폭 반영
  document.documentElement.style.setProperty('--token-col-mm', String(opts.tokenMM));

  // 표기칸 내부 가용 폭(px): tokenMM - (padding+border) 근사
  const tokenCellPx = mmToPx(opts.tokenMM);
  const tokenInnerPx = tokenCellPx - 4 - 1; // 좌우 padding 2px+2px, border-right 1px

  let count = 0;
  tokens.forEach(tok => {
    if (!tok) return;

    const tr = document.createElement('tr');

    // 표기(자동 글자축소)
    const tdTok = document.createElement('td');
    tdTok.className = 'token';
    const fs = fitFontSize(tok, tokenInnerPx);
    tdTok.style.fontSize = fs + 'px';
    tdTok.textContent = tok;
    tr.appendChild(tdTok);

    // 따라쓰기(세로줄 + 가로줄)
    const tdLines = document.createElement('td');
    tdLines.className = 'lines';
    const band = document.createElement('div');
    band.className = 'lineband';
    tdLines.appendChild(band);
    tr.appendChild(tdLines);
    rows.appendChild(tr);

    // 행이 DOM에 들어간 후 실제 폭 측정
    const tokenPxShown = measurePx(tok, fs);
    const writingPx = band.getBoundingClientRect().width;
    const n = lineCountBy(tokenPxShown, writingPx, opts.SCALE, opts.MIN_LINES, opts.MAX_LINES);

    for(let i=0;i<n;i++){
      const v = document.createElement('span');
      v.className = 'vline';
      band.appendChild(v);
    }
    count++;
  });
  document.getElementById('count').textContent = `항목: ${count}개`;
}

/* ==== 입력 → 토큰화 (짧게 토막나는 단어 모드) ==== */
/* 문장/구두점 → 조사에서 1차 분할 → 스크립트(한자/가나) 경계에서 2차 분할
   → 한자 클러스터는 KANJI_CHUNK(기본 1글자)로 잘라서 아주 짧게 만들고
   → 바로 뒤의 오쿠리가나는 최대 OKURI_TAIL(기본 1글자)까지만 붙임
   → 너무 길면 MAX_SUBLEN으로 최종 토막
   ※ 항상 '한자 1자 이상 포함' 조각만 채택
*/

const SENT_SPLIT = /[。．！？?!、，,;:()\[\]「」『』【】〈〉《》\n\r]+/;
const PARTICLES  = /(から|まで|より|[はがをにでへともやの])/g;
const JP_SEQ     = /[\p{Script=Han}\p{Script=Hiragana}\p{Script=Katakana}ー]+/gu;
const HAS_HAN    = /\p{Script=Han}/u;

const MAX_SUBLEN   = 3;  // 최종 조각 최대 길이(더 짧게 하려면 2~3 권장)
const KANJI_CHUNK  = 1;  // 한자 클러스터 분해 단위(1이면 한자 1글자씩)
const OKURI_TAIL   = 1;  // 한자 뒤에 붙일 오쿠리가나 최대 길이(0~1 추천)

/* 한 글자의 스크립트 판별 */
function scriptOf(ch){
  if (/\p{Script=Han}/u.test(ch)) return 'Han';
  if (/\p{Script=Hiragana}/u.test(ch)) return 'Hira';
  if (/\p{Script=Katakana}/u.test(ch) || ch === 'ー') return 'Kata';
  return 'Other';
}

/* 스크립트 경계로 run 분리 */
function splitRuns(seg){
  const chars = [...seg];
  if (chars.length===0) return [];
  let runs = [];
  let cur = chars[0], t = scriptOf(chars[0]);
  for (let i=1;i<chars.length;i++){
    const ti = scriptOf(chars[i]);
    if (ti === t) cur += chars[i];
    else { runs.push({t, s: cur}); cur = chars[i]; t = ti; }
  }
  runs.push({t, s: cur});
  return runs;
}

/* run들을 아주 짧은 조각으로 변환: 한자 run은 1글자(or KANJI_CHUNK)씩,
   뒤따르는 가나는 최대 OKURI_TAIL만 직전 한자 토막에 붙임 */
function explodePieces(seg){
  const runs = splitRuns(seg);
  const out = [];
  for (let i=0;i<runs.length;i++){
    const r = runs[i];
    if (r.t === 'Han'){
      const ks = [...r.s];
      for (let k=0;k<ks.length;k+=KANJI_CHUNK){
        out.push(ks.slice(k, k+KANJI_CHUNK).join(''));
      }
      // 바로 뒤 run이 가나면 최대 OKURI_TAIL만 마지막 조각에 붙임
      const nxt = runs[i+1];
      if (nxt && (nxt.t==='Hira' || nxt.t==='Kata') && out.length){
        const kana = [...nxt.s];
        if (OKURI_TAIL > 0){
          out[out.length-1] += kana.slice(0, OKURI_TAIL).join('');
        }
        // 나머지 가나는 한자가 없으므로 버림(원하면 보존 가능)
        // 소비 처리: 다음 루프에서 건너뛰도록 i 증가
        runs[i+1] = {t:'Other', s:''};
      }
    } else {
      // 가나/기타 run은 기본적으로 버림(한자 포함 토막만 필요)
    }
  }
  // 너무 긴 토막은 MAX_SUBLEN으로 최종 슬라이스
  const finalPieces = [];
  for (const p of out){
    const arr = [...p];
    for (let i=0;i<arr.length;i+=MAX_SUBLEN){
      const piece = arr.slice(i, i+MAX_SUBLEN).join('');
      if (HAS_HAN.test(piece)) finalPieces.push(piece);
    }
  }
  return finalPieces;
}

/* 새 extractWords: 문장/구두점 → 조사 → 스크립트 경계 → 초단위 토막 */
function extractWords(text){
  const out = [];
  const sentences = text.split(SENT_SPLIT).filter(Boolean);
  for (const s of sentences){
    const chunks = s.match(JP_SEQ) || [];
    for (const ch of chunks){
      // 조사 주변에서 분할
      const segs = ch.replace(PARTICLES, ' $1 ').split(/\s+/).filter(Boolean);
      for (const seg of segs){
        if (!HAS_HAN.test(seg)) continue;            // 한자 미포함 제외
        const pieces = explodePieces(seg);
        for (const p of pieces) out.push(p);
      }
    }
  }
  return out;
}

/* 모드/중복 제거 적용 — extractKanjiChars는 기존 정의를 그대로 사용 */
function buildTokens(text, mode, dedupe){
  let arr = (mode === 'kanji') ? extractKanjiChars(text) : extractWords(text);
  if (dedupe){
    const seen = new Set();
    arr = arr.filter(x => (seen.has(x) ? false : (seen.add(x), true)));
  }
  return arr;
}

/* ==== 이벤트 ==== */
document.getElementById('btnGen').addEventListener('click', () => {
  const text = document.getElementById('src').value || '';
  const mode = document.querySelector('input[name="mode"]:checked').value;
  const dedupe = document.getElementById('dedupe').checked;
  const tokenMM = parseFloat(document.getElementById('tokenMM').value) || 60;
  const SCALE = parseFloat(document.getElementById('scale').value) || 1.0;
  const MIN_LINES = parseInt(document.getElementById('minLines').value) || 6;
  const MAX_LINES = parseInt(document.getElementById('maxLines').value) || 24;

  const tokens = buildTokens(text, mode, dedupe);
  render(tokens, { tokenMM, SCALE, MIN_LINES, MAX_LINES });
});

document.getElementById('btnPrint').addEventListener('click', () => window.print());
</script>
</body>
</html>